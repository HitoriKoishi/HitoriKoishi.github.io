<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go语言入门 | Aris系统已上线</title><meta name="author" content="HitoriKoishi"><meta name="copyright" content="HitoriKoishi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="程序结构 声明与变量 在 Go 语言中，字面量（Literal） 的概念和 C++ 中的字面量非常相似，都是指在代码中直接表示固定值的符号或表达式。它们用于表示基本数据类型（如整数、浮点数、字符、字符串等）的常量值，而无需通过变量或计算来获取。    场景 短赋值 :&#x3D; 一般赋值 &#x3D;     函数内声明新变量 ✅ ❌（需配合 var）   包作用域变量赋值 ❌ ✅   仅赋值（变量已声明） ❌ ✅">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言入门">
<meta property="og:url" content="https://hitorikoishi.github.io/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Aris系统已上线">
<meta property="og:description" content="程序结构 声明与变量 在 Go 语言中，字面量（Literal） 的概念和 C++ 中的字面量非常相似，都是指在代码中直接表示固定值的符号或表达式。它们用于表示基本数据类型（如整数、浮点数、字符、字符串等）的常量值，而无需通过变量或计算来获取。    场景 短赋值 :&#x3D; 一般赋值 &#x3D;     函数内声明新变量 ✅ ❌（需配合 var）   包作用域变量赋值 ❌ ✅   仅赋值（变量已声明） ❌ ✅">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hitorikoishi.github.io/img/background_1.jpg">
<meta property="article:published_time" content="2025-06-24T15:15:11.000Z">
<meta property="article:modified_time" content="2025-06-30T09:34:54.289Z">
<meta property="article:author" content="HitoriKoishi">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hitorikoishi.github.io/img/background_1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go语言入门",
  "url": "https://hitorikoishi.github.io/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/",
  "image": "https://hitorikoishi.github.io/img/background_1.jpg",
  "datePublished": "2025-06-24T15:15:11.000Z",
  "dateModified": "2025-06-30T09:34:54.289Z",
  "author": [
    {
      "@type": "Person",
      "name": "HitoriKoishi",
      "url": "https://hitorikoishi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hitorikoishi.github.io/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go语言入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Aris系统已上线" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="Aris系统已上线" type="application/rss+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background_1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Aris系统已上线</span></a><a class="nav-page-title" href="/"><span class="site-name">Go语言入门</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Go语言入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-24T15:15:11.000Z" title="Created 2025-06-24 23:15:11">2025-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-30T09:34:54.289Z" title="Updated 2025-06-30 17:34:54">2025-06-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>程序结构</h1>
<h2 id="声明与变量">声明与变量</h2>
<p>在 Go 语言中，<strong>字面量（Literal）</strong> 的概念和 C++ 中的字面量非常相似，都是指在代码中直接表示固定值的符号或表达式。它们用于表示基本数据类型（如整数、浮点数、字符、字符串等）的常量值，而无需通过变量或计算来获取。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>场景</strong></th>
<th style="text-align:left">短赋值 <code>:=</code></th>
<th style="text-align:left">一般赋值 <code>=</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">函数内声明新变量</td>
<td style="text-align:left">✅</td>
<td style="text-align:left">❌（需配合 <code>var</code>）</td>
</tr>
<tr>
<td style="text-align:left">包作用域变量赋值</td>
<td style="text-align:left">❌</td>
<td style="text-align:left">✅</td>
</tr>
<tr>
<td style="text-align:left">仅赋值（变量已声明）</td>
<td style="text-align:left">❌</td>
<td style="text-align:left">✅</td>
</tr>
<tr>
<td style="text-align:left">多变量赋值（含新变量）</td>
<td style="text-align:left">✅</td>
<td style="text-align:left">❌</td>
</tr>
<tr>
<td style="text-align:left">显式指定变量类型</td>
<td style="text-align:left">❌</td>
<td style="text-align:left">✅（配合 <code>var</code>）</td>
</tr>
</tbody>
</table>
<h2 id="流程控制">流程控制</h2>
<h3 id="for"><strong>for</strong></h3>
<p>Go 只有一种循环结构：<code>for</code> 循环。基本的 <code>for</code> 循环由三部分组成，它们用分号隔开，表达式外无需小括号 <code>( )</code>，而大括号 <code>&#123; &#125;</code> 则是必须的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	sum += i+sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化语句和后置语句是可选的，且可以去掉分号，此时for相当于C++中的while</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑 <code>for &#123; &#125;</code></p>
<p><strong><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本</p>
</li>
</ul>
<p><s>也是融合了c++两种for循环写法，索引遍历和迭代器遍历</s></p>
<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure>
<h3 id="if-else"><strong>if else</strong></h3>
<p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code>，而大括号 <code>&#123; &#125;</code> 则是必须的</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>和 <code>for</code> 一样，<code>if</code> 语句可以在条件表达式前执行一个简短语句，该语句声明的变量作用域仅在 <code>if</code> 之内。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>if</code> 的简短语句中声明的变量同样可以在对应的任何 <code>else</code> 块中使用。<code>if</code> 和 <code>else</code> 的使用方式除去小括号外与C++一致</p>
<h3 id="swtich-case"><strong>swtich case</strong></h3>
<p><code>switch</code> 语句是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个 <code>case</code> 值 值等于条件表达式的子句。</p>
<p>Go 只会运行选定的 <code>case</code>，而非之后所有的 <code>case</code>。 在效果上，Go 的做法相当于这些语言中为每个 <code>case</code> 后面自动添加了所需的 <code>break</code> 语句。 在 Go 中，除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>case</code> 无需为常量，且取值不限于整数</strong></p>
</li>
<li class="lvl-2">
<p><strong><code>case</code> 语句从上到下顺次执行，直到匹配成功时停止</strong></p>
</li>
<li class="lvl-2">
<p>无条件的 <code>switch</code> 同 <code>switch true</code> 一样，该形式能将一长串 <code>if-then-else</code> 写得更加清晰。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;早上好！&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;下午好！&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;晚上好！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🔥defer推迟">🔥<strong>defer推迟</strong></h3>
<p>defer 语句会将函数推迟到外层函数返回之后执行。<strong>推迟调用的函数其参数会立即求值</strong>，但只会在<strong>外层函数返回前该函数才会被调用</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。</p>
</li>
</ul>
<h1>复合数据类型</h1>
<h2 id="指针"><strong>指针</strong></h2>
<p>一如C语言，其保存了值的内存地址</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针，其零值为 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;ig</span><br></pre></td></tr></table></figure>
<p><code>*</code> 操作符表示指针指向的底层值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure>
<p>这也就是通常所说的「解引用」或「间接引用」。</p>
<p>与 C 不同，Go 无法对指针进行四则运算，即直接修改地址，能够保障内存的安全性</p>
<h2 id="结构体"><strong>结构体</strong></h2>
<p>一个 结构体（<code>struct</code>）就是一组 字段（field）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="type">int</span></span><br><span class="line">	Y <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结构体指针</strong></p>
<p>如果我们有一个指向结构体的指针 <code>p</code> 那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。 不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，直接写 <code>p.X</code> 就可以。</p>
<h2 id="数组"><strong>数组</strong></h2>
<p>类型 <code>[n]T</code> 表示一个数组，它拥有 <code>n</code> 个类型为 <code>T</code> 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数组的长度是其类型的一部分，因此数组不能改变大小。</p>
</li>
</ul>
<h2 id="🔥切片">🔥<strong>切片</strong></h2>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。.</p>
<p>切片通过两个下标来界定，一个下界和一个上界，二者以冒号分隔：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure>
<p>它会选出一个半闭半开区间，包括第一个元素，但排除最后一个元素。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>切片就像数组的引用，<strong>切片并不存储任何数据，它只是映射了底层数组</strong>，更改切片的元素会修改其底层数组中对应的元素</p>
</li>
<li class="lvl-2">
<p><strong>切片下界的默认值为 0，上界则是该切片的长度</strong></p>
</li>
</ul>
<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>切片的长度就是它所包含的元素个数</p>
</li>
<li class="lvl-2">
<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数</p>
</li>
<li class="lvl-2">
<p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取</p>
</li>
</ul>
<p>切片的零值是 <code>nil</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>nil 切片的长度和容量为 0 且没有底层数组</p>
</li>
</ul>
<p>切片可以用内置函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure>
<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br></pre></td></tr></table></figure>
<p><strong>切片可以包含任何类型，当然也包括其他切片</strong>，可以使用切片嵌套来创建更高维的数据结构</p>
<p>Go 提供了内置的 <code>append</code> 函数为切片追加新的元素，内置函数的文档对该函数有详细的介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span></span> []T</span><br></pre></td></tr></table></figure>
<p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。<s>真的像vector吧</s></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="map映射">map映射</h2>
<p><code>map</code> 映射将键映射到值。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p><strong>声明一个key为string类型，value为int类型的map</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p><strong>短赋值一个key为string类型，value为int类型的map</strong></p>
<p>映射的字面量和结构体类似，只不过必须有键名，若顶层类型只是一个类型名，那么你可以在字面量的元素中省略它。</p>
<p><strong>修改映射</strong></p>
<p>在映射 <code>m</code> 中插入或修改元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure>
<p>获取元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key)</span><br></pre></td></tr></table></figure>
<p>通过双赋值检测某个键是否存在：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>
<p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p>
<p>若 <code>key</code> 不在映射中，则 <code>elem</code> 是该映射元素类型的零值。</p>
<p><strong>注</strong>：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok := m[key]</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<p>函数也是值</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>它们可以像其他值一样传递。</p>
</li>
<li class="lvl-2">
<p>函数值可以用作函数的参数或返回值。</p>
</li>
</ul>
<p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line">	fmt.Println(compute(hypot))</span><br><span class="line">	fmt.Println(compute(math.Pow))</span><br><span class="line">    <span class="comment">//结果为13 5 81</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数闭包</strong>🔥🔥🔥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos, neg := adder(), adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(</span><br><span class="line">			pos(i),</span><br><span class="line">			neg(<span class="number">-2</span>*i),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pos 和 neg 这两个变量，都是通过 adder() 函数创建的闭包</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>adder() 函数返回一个函数 func(int) int</p>
</li>
</ul>
<p>即pos和neg变量都可以视作为一个函数，并且具有一个外部变量sum：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum += x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>它们引用的闭包中的 sum 变量跟随 main 函数的生命周期，因此每次调用pos和neg时会在上一次加和的基础上进行计算</strong></p>
<h1>方法与接口</h1>
<h2 id="方法">方法</h2>
<p>Go 没有类。不过你可以为类型定义方法。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
</li>
<li class="lvl-2">
<p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
</li>
</ul>
<p>在此例中，<code>Abs</code> 方法拥有一个名字为 <code>v</code>，类型为 <code>Vertex</code> 的接收者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法只是个带接收者参数的函数，上下两段代码等效</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以为非结构体类型声明方法，但<strong>接收者的类型定义和方法声明必须在同一包内</strong></p>
<p><strong>接收者参数需要在函数内再进行一次赋值才能进行迭代</strong>，若是<strong>直接对接收者参数操作</strong>则只会产生一个新的局部变量，无法真正影响到接收者参数的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *List[T]</span><br><span class="line">	val  T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List[T])</span></span> Print() &#123;</span><br><span class="line">	current := l</span><br><span class="line">	<span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(current.val)</span><br><span class="line">		current = current.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法:</span></span><br><span class="line"><span class="comment">//这种写法是修改了方法内的局部变量 l，修改不会影响下一次循环，原始的 l 指针并没有改变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List[T])</span></span> Print() &#123;</span><br><span class="line">    <span class="keyword">if</span> l != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(l.val)</span><br><span class="line">    l = l.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	head := &amp;List[<span class="type">int</span>]&#123;<span class="literal">nil</span>, <span class="number">1</span>&#125;</span><br><span class="line">	head.next = &amp;List[<span class="type">int</span>]&#123;<span class="literal">nil</span>, <span class="number">2</span>&#125;</span><br><span class="line">	head.next.next = &amp;List[<span class="type">int</span>]&#123;<span class="literal">nil</span>, <span class="number">3</span>&#125;</span><br><span class="line">	head.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口">接口</h2>
<p><strong>接口类型</strong> 的定义为一组方法签名，接口类型的变量可以持有任何实现了这些方法的值。</p>
<p>接口也是值。它们可以像其它值一样传递。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口值可以用作函数的参数或返回值。</p>
</li>
<li class="lvl-2">
<p>在内部，接口值可以看做包含值和具体类型的元组：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, type)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口值保存了一个具体底层类型的具体值。</p>
</li>
<li class="lvl-2">
<p>接口值调用方法时会执行其底层类型的同名方法。</p>
</li>
</ul>
<p>接口的本质：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口就像是一个&quot;合同&quot;或&quot;协议&quot;</p>
</li>
<li class="lvl-2">
<p>它定义了一组方法，但只声明这些方法应该做什么，而不具体实现</p>
</li>
<li class="lvl-2">
<p>任何类型只要实现了接口中定义的所有方法，就自动实现了这个接口</p>
</li>
</ul>
<p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用， <strong>保存了 nil 具体值的接口其自身并不为 nil。</strong></p>
<p>nil 接口值（即仅声明不赋值）既不保存值也不保存具体类型，为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p>
<p>指定了零个方法的接口值被称为<strong>空接口：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>
<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p>
<h2 id="类型断言">类型断言</h2>
<p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure>
<p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p>
<p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个 panic。</p>
<p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure>
<p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生 panic。</p>
<h2 id="Stringer">Stringer</h2>
<p><a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接通过<code>Stringer</code> 自定义输出类型</p>
<h2 id="错误">错误</h2>
<p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>error 是一个接口，它要求实现者必须提供一个 Error() string 方法。</p>
</li>
<li class="lvl-2">
<p>任何类型只要实现了 Error() string 方法，就可以作为 error 类型使用。</p>
</li>
</ul>
<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包也会根据对 <code>error</code> 的实现来打印值。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure>
<p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p>
<h2 id="Readers">Readers</h2>
<p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示数据流的读取端。</p>
<p>Go 标准库包含了该接口的<a target="_blank" rel="noopener" href="https://cs.opensource.google/search?q=Read(%5Cw%2B%5Cs%5B%5Dbyte)&amp;ss=go%2Fgo">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>
<p><code>b []byte</code> 表示Read输入数据所使用的buffer，返回的 <code>int</code> 为buffer长度（填充的字节数），<code>error</code> 为错误值，在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
<p>示例代码创建了一个 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p>
<p><strong>嵌套Reader</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rot13Reader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 首先从底层的 Reader 读取数据</span></span><br><span class="line">	n, err := r.r.Read(b)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> n &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> b[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">			b[i] = <span class="string">&#x27;A&#x27;</span> + (b[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">13</span>)%<span class="number">26</span></span><br><span class="line">		<span class="keyword">case</span> b[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">			b[i] = <span class="string">&#x27;a&#x27;</span> + (b[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">13</span>)%<span class="number">26</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := strings.NewReader(<span class="string">&quot;Lbh penpxrq gur pbqr!&quot;</span>)</span><br><span class="line">	r := rot13Reader&#123;s&#125;</span><br><span class="line">	io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个实现了 <code>io.Reader</code> 并从另一个 <code>io.Reader</code> 中读取数据的 <code>rot13Reader</code>，通过应用 rot13 代换密码对数据流进行修改。</p>
<h1>泛型</h1>
<h2 id="泛型函数">泛型函数</h2>
<p>可以使用类型参数编写 Go 函数来处理多种类型。 函数的类型参数出现在函数参数之前的方括号之间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Index[T comparable](s []T, x T) int</span><br></pre></td></tr></table></figure>
<p>此声明意味着 <code>s</code> 是满足内置约束 <code>comparable</code> 的任何类型 <code>T</code> 的切片。 <code>x</code> 也是相同类型的值。</p>
<p><code>comparable</code> 是一个有用的约束，它能让我们对任意满足该类型的值使用 <code>==</code> 和 <code>!=</code> 运算符。在此示例中，我们使用它将值与所有切片元素进行比较，直到找到匹配项。 该 <code>Index</code> 函数适用于任何支持比较的类型。</p>
<h2 id="泛型类型">泛型类型</h2>
<p>除了泛型函数之外，Go 还支持泛型类型。 类型可以使用类型参数进行参数化，这对于实现通用数据结构非常有用。</p>
<h1>并发</h1>
<h2 id="Go-程（goroutine）"><strong>Go 程（goroutine）</strong></h2>
<p>由 Go 运行时管理的轻量级线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure>
<p>会启动一个新的 Go 协程并执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></table></figure>
<p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 协程中，而 <code>f</code> 的执行发生在新的 Go 协程中。</p>
<h2 id="信道">信道</h2>
<p>信道是带有类型的管道，元素先进先出，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    // 将 v 发送至信道 ch。</span><br><span class="line">v := &lt;-ch  // 从 ch 接收值并赋予 v。</span><br></pre></td></tr></table></figure>
<p>（“箭头”就是数据流的方向。）</p>
<p>和映射与切片一样，信道在使用前必须创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure>
<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<p><strong>带缓冲的信道</strong></p>
<p>信道可以是 <strong>带缓冲的</strong>。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 100)</span><br></pre></td></tr></table></figure>
<p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>
<p><strong>缓冲区若填满会产生死锁</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://hitorikoishi.github.io">HitoriKoishi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://hitorikoishi.github.io/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/">https://hitorikoishi.github.io/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post-share"><div class="social-share" data-image="/img/background_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/21/Google-File-System-%E7%AC%94%E8%AE%B0/" title="Google File System 笔记"><img class="cover" src="/img/background_3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Google File System 笔记</div></div><div class="info-2"><div class="info-item-1">使用了单一主控方式，master仅储存文件的元数据，包括区块命名空间，文件和区块的映射，以及每个区块副本的位置，这些都直接存储在master的内存里，因此访问速度很快 操作日志很重要，是元数据的持久性记录，并且充当了定义并发操作顺序的逻辑时间线 GFS 的主要需求 在学习 GFS 的原理前，首先我们应当了解 GFS 在设计时所面对的需求场景。简单概括，GFS 的设计主要基于以下几个需求：   节点失效是常态。系统会构建在大量的普通机器上，这使得节点失效的可能性很高。因此，GFS 必须能有较高的容错性、能够持续地监控自身的状态，同时还要能够顺畅地从节点失效中快速恢复   存储内容以大文件为主。系统需要存储的内容在通常情况下由数量不多的大文件构成，每个文件通常有几百 MB 甚至是几 GB 的大小；系统应当支持小文件，但不需要为其做出优化   主要负载为大容量连续读、小容量随机读以及追加式的连续写   系统应当支持高效且原子的文件追加操作，源于在 Google 的情境中，这些文件多用于生产者-消费者模式或是多路归并   当需要做出取舍时，系统应选择高数据吞吐量而不是低延时   GFS...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HitoriKoishi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HitoriKoishi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/HitoriKoishi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">record the moment</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">声明与变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">1.2.1.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else"><span class="toc-number">1.2.2.</span> <span class="toc-text">if else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swtich-case"><span class="toc-number">1.2.3.</span> <span class="toc-text">swtich case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5defer%E6%8E%A8%E8%BF%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">🔥defer推迟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.2.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A5%E5%88%87%E7%89%87"><span class="toc-number">2.4.</span> <span class="toc-text">🔥切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E6%98%A0%E5%B0%84"><span class="toc-number">2.5.</span> <span class="toc-text">map映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">方法与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.3.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stringer"><span class="toc-number">3.4.</span> <span class="toc-text">Stringer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">3.5.</span> <span class="toc-text">错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Readers"><span class="toc-number">3.6.</span> <span class="toc-text">Readers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">泛型类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E7%A8%8B%EF%BC%88goroutine%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">Go 程（goroutine）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E9%81%93"><span class="toc-number">5.2.</span> <span class="toc-text">信道</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" title="Go语言入门"><img src="/img/background_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言入门"/></a><div class="content"><a class="title" href="/2025/06/24/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" title="Go语言入门">Go语言入门</a><time datetime="2025-06-24T15:15:11.000Z" title="Created 2025-06-24 23:15:11">2025-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/Google-File-System-%E7%AC%94%E8%AE%B0/" title="Google File System 笔记"><img src="/img/background_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Google File System 笔记"/></a><div class="content"><a class="title" href="/2025/06/21/Google-File-System-%E7%AC%94%E8%AE%B0/" title="Google File System 笔记">Google File System 笔记</a><time datetime="2025-06-21T12:17:57.000Z" title="Created 2025-06-21 20:17:57">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/18/c-whale-market%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" title="c++ whale market项目总结"><img src="/img/background_2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++ whale market项目总结"/></a><div class="content"><a class="title" href="/2025/02/18/c-whale-market%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" title="c++ whale market项目总结">c++ whale market项目总结</a><time datetime="2025-02-18T10:10:30.000Z" title="Created 2025-02-18 18:10:30">2025-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/16/HelloWorld/" title="HelloWorld"><img src="/img/background_4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HelloWorld"/></a><div class="content"><a class="title" href="/2025/01/16/HelloWorld/" title="HelloWorld">HelloWorld</a><time datetime="2025-01-16T05:38:05.000Z" title="Created 2025-01-16 13:38:05">2025-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By HitoriKoishi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>